# 클로저 (Closures)

<br/>

## 렉시컬 스코프

자바스크립트는 `렉시컬 스코프`를 따른다. 함수의 호출 위치가 아니라, `함수를 정의한 위치`에 따라 `상위 스코프가 결정`되고, 변하지 않는다.

<br/>

## 함수 객체의 내부 슬롯 [[Environment]]

렉시컬 스코프가 가능하려면, 함수는 상위 스코프를 기억해야 한다.  
이를 위해 함수는 자신의 내부 슬롯 `[[Environment]]`에 자신이 정의된 환경, 즉 `상위 스코프의 참조를 저장`한다.

<br/>

## 클로저

외부 함수보다 중첩 함수(내부 함수)가 더 오래 유지되는 경우, 중첩 함수는 `생명 주기가 종료한` 외부 함수의 변수(자유 변수, free variable)를 참조할 수 있다. 이러한 중첩 함수를 `클로저`라고 부른다.

<br/>

```js
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

/**
 *  함수 outer를 호출하면 내부 함수 inner가 반환된다.
 *  그리고 함수 outer의 실행 컨텍스트는 소멸한다.
 */
const innerFunc = outer();
innerFunc(); // 10
```

<br/>

outer 함수의 실행 컨텍스트는 콜스택에서 제거되지만, outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다.  
outer 함수의 렉시컬 환경은 inner 함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있고, inner 함수는 전역 변수 innerFunc에 참조되고 있기 때문이다.  
`가비지 컬렉터`는 누군가가 참조하고 있는 메모리 공간을 제거하지 않는다!  
이처럼 중첩 함수 inner의 내부에서는 상위 스코프를 참조할 수 있으므로 `상위 스코프의 식별자를 참조`할 수 있고, `값을 변경`할 수도 있다.

<br/>

외부 함수가 종료하여 실행 컨텍스트가 반환되어도, 외부 함수 실행 컨텍스트 내의 활성 객체(activation object)는 내부 함수에 의해 참조되는 한 유효하다. 따라서 내부 함수는 스코프 체인을 통해 외부 함수 내의 변수를 참조할 수 있다.

<br/>

이처럼 클로저는 반환된 내부함수가 자신이 선언됐을 때의 렉시컬 환경인 스코프를 기억하여, 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말한다. 즉, `클로저는 자신이 생성될 때의 렉시컬 환경을 기억하는 함수`다.

<br/>

자바스크립트의 모든 함수는 상위 스코프를 기억하기 때문에 `이론적으로는 모든 함수가 클로저`다.  
하지만 다음의 조건을 충족할 때만 한정된다.

1. 중첩 함수가 상위 스코프의 식별자를 참조하고 있는 경우.
2. 중첩 함수가 외부 함수보다 더 오래 유지되는 경우.

<br/>

출처: https://poiemaweb.com/js-closure
